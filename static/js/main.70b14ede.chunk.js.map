{"version":3,"sources":["face-detector/common/opencv.ts","face-detector/common/loader.js","face-detector/index.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Eevents","paths","onloadCallback","a","OPENCV_URL","asmPath","wasmPath","Object","Error","wasmSupported","WebAssembly","console","log","script","document","createElement","setAttribute","addEventListener","src","node","getElementsByTagName","parentNode","insertBefore","FaceDetector","context","options","_output_render_context","_video","_stream","MediaStream","_is_scanning","_anim_id","_interval_id","grey","faces","eyes","border_width","border_colour","position","worker","fillStyle","fillRect","canvas","width","height","window","Worker","onmessage","e","this","data","_callbacks","found","face","bind","image_data","getImageData","postMessage","setTimeout","_read","clearTimeout","originalRatios","videoWidth","videoHeight","coverRatio","Math","max","newImageWidth","newImageHeight","x","y","drawImage","beginPath","lineWidth","strokeStyle","rect","topLeft","bottomRight","stroke","forEach","eye","requestAnimationFrame","_render","cancelAnimationFrame","text","lineHeight","maxWidth","getBoundingClientRect","words","split","line","font","textAlign","n","length","testLine","measureText","fillText","Promise","resolve","reject","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","frameRate","srcObject","play","error","print","pause","getTracks","track","stop","face_cascade","delete","eye_cascade","_is_ready","cv","matFromImageData","Mat","cvtColor","COLOR_RGBA2GRAY","RectVector","msize","Size","detectMultiScale","i","size","roiGray","roi","get","roiSrc","point1","Point","point2","j","push","loadOpenCV","wasm","ready","CascadeClassifier","createFileFromUrl","load","path","url","callback","request","XMLHttpRequest","open","responseType","onload","ev","readyState","status","Uint8Array","response","FS_createDataFile","send","event","App","face_detector","getElementById","getContext","on","detect","res","className","id","onClick","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.70b14ede.chunk.js","sourcesContent":["import {loadOpenCV} from './loader.js';\r\nexport declare type Dimension = {\r\n    x: number;\r\n    y: number;\r\n};\r\nexport declare type Rect = {\r\n    topLeft: Dimension;\r\n    bottomRight: Dimension;\r\n}\r\nexport interface IPosition {\r\n    eyes?: Rect[];\r\n    face?: Rect;\r\n}\r\nexport interface IResult {\r\n    error: string;\r\n    position: IPosition;\r\n    profile_info: string;\r\n}\r\nexport declare class Result implements IResult {\r\n    error: string;\r\n    position: IPosition;\r\n    profile_info: string;\r\n    constructor(result?: {\r\n        error?: string;\r\n        position?: IPosition;\r\n        profile_info?: string;\r\n    });\r\n}\r\n\r\nexport interface ICallbacks {\r\n    ready?: Function;\r\n    error?: Function;\r\n    found?: Function;\r\n}\r\n\r\nenum Eevents {\r\n    ready,\r\n    error,\r\n    found\r\n}\r\nexport type events = keyof typeof Eevents;\r\n\r\nexport abstract class OpenCV {\r\n    protected cv : any;\r\n    protected _is_ready : boolean;\r\n    protected _callbacks : ICallbacks = {};\r\n    protected face_cascade : any;\r\n    protected eye_cascade : any;\r\n    constructor() {\r\n        // Set paths configuration\r\n        let pathsConfig = {\r\n            wasm: \"./opencv.js\",\r\n        }\r\n        // Load OpenCV.js and use the pathsConfiguration and main function as the params.\r\n        this.cv = {};\r\n        this._is_ready = false;\r\n        if (!(window as any).cv) {\r\n            loadOpenCV(pathsConfig, async function(this : OpenCV) {\r\n                this.cv = await (window as any).cv;\r\n                this._is_ready = true;\r\n                if (this._callbacks.ready) {\r\n                    this.face_cascade = new this.cv.CascadeClassifier();\r\n                    this.eye_cascade = new this.cv.CascadeClassifier();\r\n                    \r\n                    this.createFileFromUrl(\"haarcascade_frontalface_default.xml\", \"./haarcascade_frontalface_default.xml\", function(this : OpenCV) {\r\n                        this.face_cascade.load(\"haarcascade_frontalface_default.xml\"); // in the callback, load the cascade from file \r\n                    }.bind(this));\r\n\r\n                    this.createFileFromUrl(\"haarcascade_eye.xml\", \"./haarcascade_eye.xml\", function(this : OpenCV) {\r\n                        this.eye_cascade.load(\"haarcascade_eye.xml\"); // in the callback, load the cascade from file \r\n                    }.bind(this));\r\n                    this._callbacks.ready();\r\n                }\r\n            }.bind(this));\r\n        }\r\n    }\r\n\r\n    private createFileFromUrl (path : string, url : string, callback : Function) {\r\n        let request = new XMLHttpRequest();\r\n        request.open('GET', url, true);\r\n        request.responseType = 'arraybuffer';\r\n        request.onload = function(this : OpenCV, ev : Event) {\r\n            if (request.readyState === 4) {\r\n                if (request.status === 200) {\r\n                    let data = new Uint8Array(request.response);\r\n                    this.cv.FS_createDataFile('/', path, data, true, false, false);\r\n                    callback();\r\n                } else {\r\n                    if (this._callbacks.error) {\r\n                        this._callbacks.error(new Error('Failed to load ' + url + ' status: ' + request.status));\r\n                    }\r\n                }\r\n            }\r\n        }.bind(this);\r\n        request.send();\r\n    };\r\n\r\n    public on(event : events, callback : Function) : void {\r\n        switch(event) {\r\n            case \"ready\":\r\n                this._callbacks.ready = callback;\r\n                break;\r\n            \r\n            case \"error\":\r\n                this._callbacks.error = callback;\r\n                break;\r\n            \r\n            case \"found\":\r\n                this._callbacks.found = callback;\r\n                break;\r\n        }\r\n    }\r\n}","//const wasmFeatureDetect = require('wasm-feature-detect');\n\nexport async function loadOpenCV(paths, onloadCallback) {\n    let OPENCV_URL = \"\";\n    let asmPath = \"\";\n    let wasmPath = \"\";\n    let simdPath = \"\";\n    let threadsPath = \"\";\n    let threadsSimdPath = \"\";\n\n    if(!(paths instanceof Object)) {\n        throw new Error(\"The first input should be a object that points the path to the OpenCV.js\");\n    }\n\n    if (\"asm\" in paths) {\n        asmPath = paths[\"asm\"];\n    }\n\n    if (\"wasm\" in paths) {\n        wasmPath = paths[\"wasm\"];\n    }\n\n    if (\"threads\" in paths) {\n        threadsPath = paths[\"threads\"];\n    }\n\n    if (\"simd\" in paths) {\n        simdPath = paths[\"simd\"];\n    }\n\n    if (\"threadsSimd\" in paths) {\n        threadsSimdPath = paths[\"threadsSimd\"];\n    }\n\n    let wasmSupported = !(typeof WebAssembly === 'undefined');\n    if (!wasmSupported && OPENCV_URL === \"\" && asmPath != \"\") {\n        OPENCV_URL = asmPath;\n        console.log(\"The OpenCV.js for Asm.js is loaded now\");\n    } else if (!wasmSupported && asmPath == \"\"){\n        throw new Error(\"The browser supports the Asm.js only, but the path of OpenCV.js for Asm.js is empty\");\n    }\n\n    let simdSupported = wasmSupported ? false : false;\n    let threadsSupported = wasmSupported ? false : false;\n\n    if (simdSupported && threadsSupported && threadsSimdPath != \"\") {\n        OPENCV_URL = threadsSimdPath;\n        console.log(\"The OpenCV.js with simd and threads optimization is loaded now\");\n    } else if (simdSupported && simdPath != \"\") {\n        if (threadsSupported && threadsSimdPath === \"\") {\n            console.log(\"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty\");\n        }\n        OPENCV_URL = simdPath;\n        console.log(\"The OpenCV.js with simd optimization is loaded now.\");\n    } else if (threadsSupported && threadsPath != \"\") {\n        if (simdSupported && threadsSimdPath === \"\") {\n            console.log(\"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty\");\n        }\n        OPENCV_URL = threadsPath;\n        console.log(\"The OpenCV.js with threads optimization is loaded now\");\n    } else if (wasmSupported && wasmPath != \"\") {\n        if(simdSupported && threadsSupported) {\n            console.log(\"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty\");\n        }\n\n        if (simdSupported) {\n            console.log(\"The browser supports simd optimization, but the path of OpenCV.js with simd optimization is empty\");\n        }\n\n        if (threadsSupported) {\n            console.log(\"The browser supports threads optimization, but the path of OpenCV.js with threads optimization is empty\");\n        }\n\n        OPENCV_URL = wasmPath;\n        console.log(\"The OpenCV.js for wasm is loaded now\");\n    } else if (wasmSupported) {\n        console.log(\"The browser supports wasm, but the path of OpenCV.js for wasm is empty\");\n    }\n\n    if (OPENCV_URL === \"\") {\n        throw new Error(\"No available OpenCV.js, please check your paths\");\n    }\n\n    let script = document.createElement('script');\n    script.setAttribute('async', '');\n    script.setAttribute('type', 'text/javascript');\n    script.addEventListener('load', () => {\n        onloadCallback();\n    });\n    script.addEventListener('error', () => {\n        console.log('Failed to load opencv.js');\n    });\n    script.src = OPENCV_URL;\n    let node = document.getElementsByTagName('script')[0];\n    if (node.src != OPENCV_URL) {\n        node.parentNode.insertBefore(script, node);\n    }\n}\n","import {OpenCV, IResult, IPosition, Dimension, Rect} from './common/opencv';\r\n\r\nexport interface IOptions {\r\n    border_width: number;\r\n    border_colour : string;\r\n}\r\nexport class FaceDetector extends OpenCV {\r\n    private _output_render_context : CanvasRenderingContext2D;\r\n    private _video : HTMLVideoElement;\r\n    private _stream : MediaStream = new MediaStream();\r\n    private _is_scanning : boolean = false;\r\n    private _anim_id : number = 0;\r\n    private _interval_id : number = 0;\r\n    private src : any;\r\n    private grey : any;\r\n    private faces : any;\r\n    private eyes : any;\r\n    private border_width : number;\r\n    private border_colour : string;\r\n    private position : IPosition;\r\n    private worker : Worker | undefined;\r\n    constructor(context : CanvasRenderingContext2D, options : IOptions) {\r\n        super();\r\n        this._output_render_context = context;\r\n        this.border_width = options.border_width;\r\n        this.border_colour = options.border_colour;\r\n        this.position = {};\r\n        this._video = document.createElement('video') as HTMLVideoElement;\r\n\r\n        //clear canvas to black\r\n        this._output_render_context.fillStyle = \"black\";\r\n        this._output_render_context.fillRect(0, 0, this._output_render_context.canvas.width, this._output_render_context.canvas.height);\r\n    \r\n        \r\n        //instantiate worker thread\r\n        if (window.Worker) {\r\n            this.worker = new Worker('./worker.js');\r\n            this.worker.onmessage = function (this : FaceDetector, e : MessageEvent) {\r\n                this.position = e.data.position;\r\n                if (this._callbacks.found) {\r\n                    if (this.position.face || this.position.eyes) {\r\n                        this._callbacks.found(e.data);\r\n                    }\r\n                }\r\n                \r\n            }.bind(this)\r\n        }\r\n    }\r\n\r\n    private async _read() {\r\n        \r\n        if (this._callbacks.found) {\r\n            const image_data : ImageData = this._output_render_context.getImageData(0, 0, this._output_render_context.canvas.width, this._output_render_context.canvas.height);\r\n            this.worker?.postMessage([image_data]);\r\n            // const start : number = Date.now();\r\n            // this.position = this.detectFaceData();     \r\n            // const end : number = Date.now();\r\n\r\n            // if (this.position.face || this.position.eyes) {\r\n            //     this._callbacks.found({\r\n            //         position: this.position,\r\n            //         profile_info: `${(end-start).toFixed(2)}ms / ${(1/((end-start)/1000)).toFixed(2)}fps`\r\n            //     });\r\n            // }\r\n        }\r\n\r\n        if (this._is_scanning) {\r\n            this._interval_id = window.setTimeout(this._read.bind(this), 80);\r\n        } else {\r\n            clearTimeout(this._interval_id);\r\n        }\r\n    }\r\n\r\n    private async _render() {\r\n        //scale to cover\r\n        var originalRatios = {\r\n            width: this._output_render_context.canvas.width / this._video.videoWidth,\r\n            height: this._output_render_context.canvas.height / this._video.videoHeight\r\n        };\r\n        \r\n        // formula for cover:\r\n        var coverRatio = Math.max(originalRatios.width, originalRatios.height); \r\n        \r\n        // result:\r\n        var newImageWidth = this._video.videoWidth * coverRatio;\r\n        var newImageHeight = this._video.videoHeight * coverRatio;\r\n\r\n        // // get the top left position of the image\r\n        var x = (this._output_render_context.canvas.width / 2) - (this._video.videoWidth / 2) * coverRatio;\r\n        var y = (this._output_render_context.canvas.height / 2) - (this._video.videoHeight / 2) * coverRatio;\r\n\r\n\r\n        this._output_render_context.drawImage(this._video, x, y, newImageWidth, newImageHeight);\r\n        if (this.position.face) {\r\n            //bounding box around face\r\n            this._output_render_context.beginPath();\r\n            this._output_render_context.lineWidth = this.border_width;\r\n            this._output_render_context.strokeStyle = this.border_colour;\r\n            this._output_render_context.rect(\r\n                this.position.face?.topLeft.x,\r\n                this.position.face?.topLeft.y,\r\n                this.position.face?.bottomRight.x - this.position.face?.topLeft.x,\r\n                this.position.face?.bottomRight.y - this.position.face?.topLeft.y\r\n            );\r\n\r\n            this._output_render_context.stroke();\r\n        }\r\n\r\n        if (this.position.eyes) {\r\n            this.position.eyes.forEach((eye) => {\r\n                this._output_render_context.beginPath();\r\n                this._output_render_context.lineWidth = this.border_width;\r\n                this._output_render_context.strokeStyle = \"blue\";\r\n                this._output_render_context.rect(\r\n                    eye.topLeft.x,\r\n                    eye.topLeft.y,\r\n                    eye.bottomRight.x - eye.topLeft.x,\r\n                    eye.bottomRight.y - eye.topLeft.y\r\n                );\r\n\r\n                this._output_render_context.stroke();\r\n            });\r\n        }\r\n        if (this._is_scanning) {\r\n            this._anim_id = window.requestAnimationFrame(this._render.bind(this));\r\n        } else {\r\n            window.cancelAnimationFrame(this._anim_id);\r\n        }\r\n        \r\n    }\r\n\r\n    public print(text : string, x : number, y : number, lineHeight : number) {\r\n        const maxWidth : number = this._output_render_context.canvas.getBoundingClientRect().width;\r\n        let words : string[] = text.split(' ');\r\n        let line : string = '';\r\n\r\n        //write error message to canvas\r\n        this._output_render_context.font = \"20px Arial\";\r\n        this._output_render_context.fillStyle = \"white\";\r\n        this._output_render_context.textAlign = \"center\";\r\n\r\n        for(let n = 0; n < words.length; n++) {\r\n          let testLine : string = line + words[n] + ' ';\r\n          let metrics : TextMetrics = this._output_render_context.measureText(testLine);\r\n          let testWidth : number = metrics.width;\r\n          if (testWidth > maxWidth && n > 0) {\r\n            this._output_render_context.fillText(line, x, y);\r\n            line = words[n] + ' ';\r\n            y += lineHeight;\r\n          }\r\n          else {\r\n            line = testLine;\r\n          }\r\n        }\r\n        this._output_render_context.fillText(line, x, y);\r\n    }\r\n\r\n    public detect() : Promise<void> {\r\n        return new Promise(async (resolve, reject) => {\r\n            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n                try {\r\n                    if (!this._is_scanning) {\r\n                        this._stream = await navigator.mediaDevices.getUserMedia({\r\n                            video: {\r\n                                width: {\r\n                                    ideal: this._output_render_context.canvas.width\r\n                                }, \r\n                                height: {\r\n                                    ideal: this._output_render_context.canvas.height\r\n                                },\r\n                                facingMode: \"user\",\r\n                                frameRate: {\r\n                                    ideal: 24\r\n                                }\r\n                            }\r\n                        });\r\n                      \r\n                        this._video.srcObject = this._stream;\r\n                        this._video?.play();\r\n                        \r\n                        this._is_scanning = true;\r\n\r\n                        this._render();\r\n                        this._read();\r\n\r\n                        resolve();\r\n    \r\n                    } else {\r\n                        const error : Error = new Error(\"Stream already initialised.\");\r\n                        if (this._callbacks.error) {\r\n                            this._callbacks.error(error);\r\n                        }\r\n\r\n                        reject(error);\r\n                    }\r\n                } catch(e) {\r\n                    if (this._callbacks.error) {\r\n                        this._callbacks.error(e);\r\n                    }\r\n\r\n                    \r\n                    this.print(\"Error. Permission denied. Please update browser permissions to access camera.\", this._output_render_context.canvas.width / 2, this._output_render_context.canvas.height / 2, 25);\r\n\r\n                    reject(e);\r\n                }\r\n            \r\n            } else {\r\n                const error : Error = new Error(\"Browser does not support getUserMedia.\");\r\n                if (this._callbacks.error) {\r\n                    this._callbacks.error(error);\r\n                }\r\n\r\n                //write error message to canvas\r\n                this.print(\"Error. Your browser does not support camera access. Use a modern browser or update your browser.\", this._output_render_context.canvas.width / 2, this._output_render_context.canvas.height / 2, 25);\r\n\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    public stop() : Promise<boolean> {\r\n        return new Promise((resolve, reject) => {\r\n            if (this._stream && this._is_scanning) {\r\n                //stop scanning\r\n                this._is_scanning = false;\r\n                //stop camera\r\n                this._video.pause();\r\n                this._video.src = \"\";\r\n                this._stream.getTracks().forEach(function(track) {\r\n                    track.stop();\r\n                });\r\n\r\n                //cleanup\r\n                this.face_cascade.delete();\r\n                this.eye_cascade.delete(); \r\n                this.src.delete();\r\n                this.grey.delete(); \r\n                this.faces.delete();\r\n                this.eyes.delete();\r\n\r\n                //clear canvas to black\r\n                this._output_render_context.fillStyle = \"black\";\r\n                this._output_render_context.fillRect(0, 0, this._output_render_context.canvas.width, this._output_render_context.canvas.height);\r\n                resolve(true);\r\n            } else {\r\n                reject(new Error(\"Stream was not initialised.\"));\r\n            }\r\n        });\r\n    }\r\n\r\n    public detectFaceData() : IPosition {\r\n        try {\r\n            if (this._is_ready && this._is_scanning) {\r\n                const image_data : ImageData = this._output_render_context.getImageData(0, 0, this._output_render_context.canvas.width, this._output_render_context.canvas.height);\r\n                this.src = this.cv.matFromImageData(image_data);\r\n                this.grey = new this.cv.Mat();\r\n                this.cv.cvtColor(this.src, this.grey, this.cv.COLOR_RGBA2GRAY, 0);                \r\n                \r\n                this.faces = new this.cv.RectVector();\r\n                this.eyes = new this.cv.RectVector();\r\n                \r\n                let position : IPosition = {};\r\n                \r\n                // detect faces\r\n                let msize = new this.cv.Size(0, 0);\r\n                this.face_cascade.detectMultiScale(this.grey, this.faces, 1.1, 3, 0, msize, msize);\r\n                for (let i = 0; i < this.faces.size(); ++i) {\r\n                    let roiGray = this.grey.roi(this.faces.get(i));\r\n                    let roiSrc = this.src.roi(this.faces.get(i));\r\n                    let point1 : Dimension = new this.cv.Point(this.faces.get(i).x, this.faces.get(i).y);\r\n                    let point2 : Dimension = new this.cv.Point(this.faces.get(i).x + this.faces.get(i).width,\r\n                                            this.faces.get(i).y + this.faces.get(i).height);\r\n\r\n                    position.face = {\r\n                        topLeft: point1,\r\n                        bottomRight: point2\r\n                    }\r\n\r\n                    position.eyes = [];\r\n\r\n                    // detect eyes in face ROI\r\n                    this.eye_cascade.detectMultiScale(roiGray, this.eyes);\r\n                    for (let j = 0; j < this.eyes.size(); ++j) {\r\n                        let point1 = new this.cv.Point(this.eyes.get(j).x, this.eyes.get(j).y);\r\n                        let point2 = new this.cv.Point(this.eyes.get(j).x + this.eyes.get(j).width,\r\n                                                this.eyes.get(j).y + this.eyes.get(j).height);\r\n                        \r\n                        position.eyes.push({\r\n                            topLeft: point1,\r\n                            bottomRight: point2\r\n                        });\r\n                        \r\n                    }\r\n                    roiGray.delete(); roiSrc.delete();\r\n                }\r\n                                \r\n                return position;\r\n            } else {\r\n                if (this._callbacks.error) {\r\n                    this._callbacks.error(new Error(\"OpenCV.js is not initalised.\"));\r\n                }\r\n                return {};\r\n            }\r\n        } catch (e) {\r\n            if (this._callbacks.error) {\r\n                this._callbacks.error(e);\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n}\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport {FaceDetector} from './face-detector';\nimport { IResult } from './face-detector/common/opencv';\n\n\n\nclass App extends React.Component {\n  private face_detector : FaceDetector | undefined;\n  componentDidMount() {\n    const canvas : HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n    const context : CanvasRenderingContext2D = canvas.getContext('2d') as CanvasRenderingContext2D;\n    \n    this.face_detector = new FaceDetector(context, {border_width: 6, border_colour: \"red\"});\n\n    \n    this.face_detector.on('ready', () => {\n      this.face_detector?.detect();\n    });\n\n    this.face_detector.on('found', (res : IResult) => {\n      if (res.position.face) {\n      }\n    })\n\n    this.face_detector.on('error', (e : Error) => {\n      console.error(e);\n      this.face_detector?.stop();\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">          \n          <div id=\"canvas-container\">\n            <canvas id=\"canvas\" width=\"480\" height=\"852\" />\n          </div>\n          <button onClick={async () => {\n            await this.face_detector?.stop();\n\n          }}>Stop</button>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}